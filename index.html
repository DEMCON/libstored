<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libstored: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libstored
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">libstored Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://github.com/DEMCON/libstored/actions?query=workflow%3ACI"></a></p>
<h1>libstored</h1>
<h2>TL;DR</h2>
<p><b>What is it?</b> A generator for a C++ class (store) with your application's variables, and a tool set to synchronize updates between processes, and debug it remotely.</p>
<p><b>When do I need it?</b> When you have a distributed application in need of synchronization, and/or you want to be able to inspect and modify internal data of a running application.</p>
<p><b>Does it work on my platform?</b> Yes.</p>
<p><b>Huh? But how you do know my hardware architecture?</b> I don't. You have to supply the drivers for your (hardware) communication interfaces, but everything else is ready to use.</p>
<p><b>Great! How do I use it?</b> Have a look at the [examples](examples).</p>
<h2>Table of contents</h2>
<ul>
<li><a href="#intro">Introduction</a></li>
<li><a href="#store">libstored - Store by description</a></li>
<li><a href="#sync">libstored - Store on a distributed system</a></li>
<li><a href="#debug">libstored - Store for Embedded Debugger</a><ul>
<li><a href="#debug_ex">Example</a></li>
<li><a href="#protocol">Embedded Debugger protocol</a></li>
</ul>
</li>
<li><a href="#build">How to build</a><ul>
<li><a href="#integrate">How to integrate in your build</a></li>
</ul>
</li>
<li><a href="#license">License</a></li>
</ul>
<h2><a class="anchor" id="intro"></a>Introduction</h2>
<p>Data is at the core of any application. And data is tricky, especially when it changes. This library helps you managing data in three ways:</p>
<ol type="1">
<li>Using a simple language, you can define which variables, types, etc., you need. Next, a C++ class is generated, with these variables, but also with iterators, run-time name lookup, synchronization hooks, and more. This is your <em>store</em>.</li>
<li>These stores can be synchronized between different instances via arbitrary communication channels. So, you can build a distributed system over multiple processes or hardware nodes, via lossy and lossless channels, over TCP, CAN, serial, you name it. When some node writes to its store, this update is distributed through your application.</li>
<li>The store can be accessed via a debugging protocol. Using this protocol, all objects in the store can be read/written or sampled at high frequency for nice plots. It offers streams to have a sort of stdout redirection or debugging output from your application. The protocol is ASCII based, and usable via PuTTY, for example. However, there is GUI and CLI implementation available, which can be extended easily to build your custom (Qt) debugging GUI.</li>
</ol>
<p>See next sections for details, but the following is worth to mention here:</p>
<ul>
<li>All code is normal C++, there are no platform-dependent constructs used. Therefore, all platforms are supported: Windows/Linux/Mac/bare metal (newlib), x86/ARM, gcc/clang/MSVC/armcc).</li>
<li>The store and all other libstored classes are not thread-safe. Using threads is troubling anyway, use <a href="https://github.com/jhrutgers/zth">fibers</a> instead.</li>
</ul>
<p>Have a look in the [<code>examples</code>](examples) directory for further in-depth reading. Refer to the <a href="https://demcon.github.io/libstored">Doxygen documentation</a> for the C++ API.</p>
<h3><a class="anchor" id="store"></a>libstored - Store by description</h3>
<p>The store is described in a simple grammar. See the <a href="https://demcon.github.io/libstored/examples.html">examples</a> directory for more explanation. This is just an impression of the syntax. </p><pre class="fragment">// Comment
// Grammar: type:size[array]=initializer long name with any character

uint32 some int
int8=42 another int, which is initialized
(uint64) time (s)

{
    bool=true b
    double[2] numbers
    string:16 s
} scope
</pre><p>The generated store (C++ class) has variables that can be accessed like this: </p><pre class="fragment">mystore.some_int = 10;
int i = mystore.another_int_which_is_initialized;
mystore.time_s.get();
mystore.scope__b = false;
mystore.scope__numbers_0.set(0.1);
mystore.scope__numbers_1.set(1.1);
mystore.scope__s.set("hello");
</pre><p>The store has a few other interesting properties:</p>
<ul>
<li>Objects can have a piece of memory as backing (just like a normal variable in a <code>struct</code>), but can also have custom callbacks on every get and set. This allows all kinds of side effects, even though the interface of the object is the same.</li>
<li>Objects are accessible using a C++ interface, but also via name lookup by string. The generator generates a compact name parser, such that names, types, and sizes can be queried dynamically.</li>
<li>A store is not thread-safe. This seems a limitation, but really, applications without threads are way easier to build and debug.</li>
</ul>
<h3><a class="anchor" id="sync"></a>libstored - Store on a distributed system</h3>
<p>Synchronization is tricky to manage. libstored helps you by providing a <a class="el" href="classstored_1_1_synchronizer.html" title="The service that manages synchronization of stores over SyncConnections. ">stored::Synchronizer</a> class that manages connections to other Synchronizers. Between these Synchronizers, one or more stores can be synchronized. The (OSI) Application layer is implemented, and several other (OSI) protocol layers are provided to configure the channels as required. These protocols are generic and also used by the debugger interface. See <a href="#debug">next section</a> for details.</p>
<p>The store provides you with enough hooks to implement any distributed memory architecture, but that is often way to complicated. The default Synchronizer is simple and efficient, but has the following limitations:</p>
<ul>
<li>Only instances of the exact same store can be synchronized. This is checked using a SHA-1 hash over the .st file of the store. That is fine if you compile your program at once, but harder to manage if components are not built in the same compile run.</li>
<li>Writes to a variable in a store should only be done by one process. If multiple processes write to the same variable, the outcome of the synchronization is undefined. However, you would have a data race in your application anyway, so this is in practice probably not really a limitation.</li>
</ul>
<p>See <a href="https://demcon.github.io/libstored/group__libstored__synchronizer.html">the doxygen documentation</a> for more details.</p>
<p>The topology is arbitrary, as long as every store instance has one root, where it gets its initial copy from. You could, for example, construct the following topology: </p><pre class="fragment">B   C
 \ /
  A
  |
  D--E--F
 / \
G   H
</pre><p>Assume that A is the first node, of all other nodes gets the initial copy from. So, D registers at A, then E gets it from D, F from E, etc. After setup, any node can write to the same store (but not to the same variable in that store). So, updates from H are first pushed to D. The D pushes them to A, E and G, and so on.</p>
<p>Different stores can have different topologies for synchronization, and synchronization may happen at different speed or interval. Everything is possible, and you can define it based on your application's needs.</p>
<p>The example <a href="examples/8_sync"><code>8_sync</code></a> implements an application with two stores, which can be connected arbitrarily using command line arguments. You can play with it to see the synchronization.</p>
<h3><a class="anchor" id="debug"></a>libstored - Store for Embedded Debugger</h3>
<p>If you have an embedded system, you probably want to debug it on-target. One of the questions you often have, is what is the value of internal variables of the program, and how can I change them? Debugging using <code>gdb</code> is great, but it pauses the application, which also stops control loops, for example.</p>
<p>Using libstored, you can access and manipulate a running system. The (OSI-stack) Application layer of this debugging interface is provided by libstored. Additionally, other layers are available to support lossless and lossy channels, which fit to common UART and CAN interfaces. You have to combine, and possibly add, and configure other (usually hardware-specific) layers of the OSI stack to get the debugging protocol in and out of your system. Although the protocol fits nicely to ZeroMQ, a TCP stream, or <code>stdio</code> via terminal, the complexity of integrating this depends on your embedded device. However, once you implemented this data transport, you can access the store, and observe and manipulate it using an Embedded Debugger (PC) client, where libstored provides Python classes, a CLI and GUI interface.</p>
<p>Your application can have one store with one debugging interface, but also multiple stores with one debugging interface, or one store with multiple debugging interfaces &ndash; any combination is possible.</p>
<p>It seems to be a duplicate to have two synchronization protocols, but both have a different purpose. For synchronization, a binary protocol is used, which only synchronizes data, using memory offsets, and some endianness. This is tightly coupled to the exact version and layout of the store. This is all known at compile time, and great for performance, but harder to manage when you start debugging. The debugging protocol is ASCII based, writable by hand, easy to use dynamic lookup of variable names, and has support to easily add custom commands by adding another capability in a subclass of <a class="el" href="classstored_1_1_debugger.html" title="The application-layer implementation of the Embedded Debugger protocol. ">stored::Debugger</a>.</p>
<h3><a class="anchor" id="debug_ex"></a>Example</h3>
<p>The host tools to debug your application are written in python, as the <code><a class="el" href="namespaceed2.html">ed2</a></code> package, and are located the <code>client</code> directory. You can run the example below by running python from the <code>client</code> directory, but you can also install the <code><a class="el" href="namespaceed2.html">ed2</a></code> package on your system. To do this, execute the <code>ed2-install</code> cmake target, such as: </p><pre class="fragment">cd build
make ed2-install
</pre><p>This builds a wheel from the <code>client</code> directory and installs it locally using <code>pip</code>. Now you can just fire up python and do <code>import <a class="el" href="namespaceed2.html">ed2</a></code>.</p>
<p>To get a grasp how debugging feels like, try the following.</p>
<ul>
<li>Build the examples, as discussed above.</li>
<li>If you use Windows, execute <code>scripts/env.cmd</code> to set your environment properly. In the instructions below, use <code>python</code> instead of <code>python3</code>.</li>
<li>Run your favorite <code>lognplot</code> instance, e.g., by running <code>python3 -m lognplot</code>.</li>
<li>Run <code>examples/zmqserver/zmqserver</code>. This starts an application with a store with all kinds of object types, and provides a ZeroMQ server interface for debugging.</li>
<li>Run <code>python3 -m <a class="el" href="namespaceed2_1_1gui.html">ed2.gui</a> -l</code> within the <code>client</code> directory. This GUI connects to both the <code>zmqserver</code> application via ZeroMQ, and to the <code>lognplot</code> instance.</li>
<li>The GUI window will pop up and show the objects of the <code>zmqserver</code> example. If polling is enabled of one of the objects, the values are forwarded to <code>lognplot</code>.</li>
</ul>
<p>The structure of this setup is: </p><pre class="fragment">+---------+        +----------+
| ed2.gui | -----&gt; | lognplot |
+---------+        +----------+
      |
      | ZeroMQ REQ/REP channel
      |
+-----------+
| zmqserver |
+-----------+
</pre><div class="image">
<img src="examples/zmqserver/zmqserver_screenshot.png" alt="zmqserver debugging screenshot"/>
</div>
<p>The Embedded Debugger client connects via ZeroMQ. If you application does not have it, you must implement is somehow. The <code>examples/terminal/terminal</code> application could be debugged as follows:</p>
<ul>
<li>Run <code>python3 -m <a class="el" href="namespaceed2_1_1wrapper_1_1stdio.html">ed2.wrapper.stdio</a> ../build/examples/terminal/terminal</code> from the <code>client</code> directory. This starts the <code>terminal</code> example, and extracts escaped debugger frames from <code>stdout</code>, which are forwarded to a ZeroMQ interface.</li>
<li>Connect a client, such as <code>python3 -m <a class="el" href="namespaceed2_1_1gui.html">ed2.gui</a></code>.</li>
</ul>
<p>The structure of this setup is: </p><pre class="fragment">+---------+
| ed2.gui |                    terminal interface
+---------+                            |
      |                                |
      | ZeroMQ REQ/REP channel         |
      |                                |
+-------------------+                  |
| ed2.wrapper.stdio | -----------------+
+-------------------+
      |
      | stdin/stdout (mixed terminal interface
      | with Embedded Debugger messages)
      |
+----------+
| terminal |
+----------+
</pre><p>There are some more ready-to-use clients, and a Python module in the <a href="https://github.com/DEMCON/libstored/tree/master/client">client</a> directory.</p>
<h3><a class="anchor" id="protocol"></a>Embedded Debugger protocol</h3>
<p>Communication with the debugger implementation in the application follows a request-response pattern. A full description of the commands can be found in the <a href="https://demcon.github.io/libstored/group__libstored__debugger.html">doxygen documentation</a>. These commands are implemented in the <a class="el" href="classstored_1_1_debugger.html" title="The application-layer implementation of the Embedded Debugger protocol. ">stored::Debugger</a> class and ready to be used in your application.</p>
<p>However, the request/response messages should be wrapped in a OSI-like protocol stack, which is described in more detail in the <a href="https://demcon.github.io/libstored/group__libstored__protocol.html">documentation too</a>). This stack depends on your application. A few standard protocol layers are available, which allow to build a stack for lossless channels (stdio/TCP/some UART) and lossy channels (some UART/CAN). These stacks are configurable in having auto retransmit on packet loss, CRC-8/16, segmentation, buffering, MTU size, ASCII escaping and encapsulation. See also <code>examples/7_protocol</code>.</p>
<p>To get a grasp about the protocol, I had a short chat with the <code>zmqserver</code> example using the <code><a class="el" href="namespaceed2_1_1cli.html">ed2.cli</a></code>. See the transcript below. Lines starting with <code>&gt;</code> are requests, entered by me, lines starting with <code>&lt;</code> are responses from the application.</p>
<p>In the example below, I used the following commands:</p>
<ul>
<li><code>?</code>: request capabilities of the target</li>
<li><code>l</code>: list object in the store</li>
<li><code>i</code>: return the identification of the target</li>
<li><code>r</code>: read an object</li>
<li><code>w</code>: write an object</li>
<li><code>v</code>: request versions</li>
<li><code>a</code>: define an alias</li>
</ul>
<p>Refer to the documentation for the details about these and other commands. </p><pre class="fragment">&gt;  ?
&lt;  ?rwelamivRWst
&gt;  l
&lt;  0110/a blob
201/a bool
2b4/a float
2f8/a double
02f/a string
312/a uint16
334/a uint32
301/a uint8
378/a uint64
234/a ptr32
278/a ptr64
392/an int16
3b4/an int32
381/an int8
3f8/an int64
7b4/compute/an int8 + an int16
734/compute/length of /a string
6f8/compute/circle area (r = /a double)
734/stats/ZMQ messages
734/stats/object writes
778/t (us)
6f8/rand

&gt;  i
&lt;  zmqserver
&gt;  r/a bool
&lt;  0
&gt;  w1/a bool
&lt;  !
&gt;  r/a bool
&lt;  1
&gt;  r/s/Z
&lt;  14
&gt;  r/s/Z
&lt;  15
&gt;  r/rand
&lt;  3d26000000000000
&gt;  r/rand
&lt;  3f50250b79ae8000
&gt;  r/rand
&lt;  3fa550a89cb27a00
&gt;  v
&lt;  2
&gt;  ar/rand
&lt;  !
&gt;  rr
&lt;  3fc69c39e2668200
&gt;  rr
&lt;  3fd755a4ab38afc0
&gt;  rr
&lt;  3fb7617168255e00
</pre><h2><a class="anchor" id="build"></a>How to build</h2>
<p>Run <code>scripts/bootstrap</code> (as Administrator under Windows) once to install all build dependencies. Then run <code>scripts/build</code> to build the project. This does effectively: </p><pre class="fragment">mkdir build
cd build
cmake ..
cmake --build .
</pre><p><code>scripts/build</code> takes an optional argument, which allows you to specify the <code>CMAKE_BUILD_TYPE</code>. If not specified, Debug is assumed.</p>
<p>By default, all examples are built. For example, notice that sources are generated under <code>examples/1_hello</code>, while the example itself is built in the <code>build</code> directory. The documentation can be viewed at <code>doxygen/html/index.html</code>.</p>
<p>To run all tests, use one of: </p><pre class="fragment">cmake --build . --target test
cmake --build . --target RUN_TESTS
</pre><h3><a class="anchor" id="integrate"></a>How to integrate in your build</h3>
<p>Building libstored on itself is not too interesting, it is about how it can generate stuff for you. This is how to integrate it in your project:</p>
<ul>
<li>Add libstored to your source repository, for example as a submodule.</li>
<li>Run <code>scripts/bootstrap</code> in the libstored directory once to install all dependencies.</li>
<li>Include libstored to your cmake project. For example: <pre class="fragment">  set(LIBSTORED_EXAMPLES OFF CACHE BOOL "Disable libstored examples" FORCE)
  set(LIBSTORED_TESTS OFF CACHE BOOL "Disable libstored tests" FORCE)
  set(LIBSTORED_DOCUMENTATION OFF CACHE BOOL "Disable libstored documentation" FORCE)
  add_subdirectory(libstored)
</pre></li>
<li>Optional: install <code>scripts/st.vim</code> in <code>$HOME/.vim/syntax</code> to have proper syntax highlighting in vim.</li>
<li>Add some store definition file to your project, let's say <code>MyStore.st</code>. Assume you have a target <code>app</code> (which can be any type of cmake target), which is going to use <code>MyStore.st</code>, generate all required files. This will generate the sources in the <code>libstored</code> subdirectory of the current source directory, a library named <code>app-libstored</code>, and set all the dependencies right. <pre class="fragment">  add_application(app main.cpp)
  libstored_generate(app MyStore.st)
</pre></li>
<li>Now, build your <code>app</code>. The generated libstored library is automatically built.</li>
</ul>
<p>Check out the examples of libstored, which are all independent applications with their own generated store.</p>
<h2><a class="anchor" id="license"></a>License</h2>
<p>The project license is specified in COPYING and COPYING.LESSER.</p>
<p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</p>
<p>You should have received a copy of the GNU Lesser General Public License along with this program. If not, see <a href="https://www.gnu.org/licenses/">https://www.gnu.org/licenses/</a>. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>

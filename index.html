<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libstored: libstored - Store for Embedded Debugger</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libstored
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">libstored - Store for Embedded Debugger </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>If you have an embedded system, you probably want to debug it on-target. One of the questions you often have, is what is the value of internal variables of the program, and how can I change them. Debugging using <code>gdb</code> is great, but it pauses the application, which also stops control loops, for example.</p>
<p>libstored helps you to access internal variables. These variables are part of a <em>store</em>. A store is defined in a simple language, and libstored provides a generator to produce a C++ class (as cmake library) with the variables you want. This generated C++ class is very efficient when accessed by the C++ application. However, it adds interesting functionality: all variables can be accessed remotely.</p>
<p>The (OSI-stack) Application layer of this debugging interface is provided by libstored. You have to add all other (usually hardware-specific) layers of the OSI stack to get the debugging protocol in and out of your system. Although the protocol fits nicely to ZeroMQ, a TCP stream, or <code>stdio</code> via terminal, the complexity of integrating this depends on your embedded device. However, once you implemented this data transport, you can access the store, and observe and manipulate it using an Embedded Debugger (PC) client, where libstored provides Python classes, a CLI and GUI interface.</p>
<p>Your application can have one store with one debugging interface, but also multiple stores with one debugging interface, or one store with multiple debugging interfaces &ndash; any combination is possible.</p>
<p>The store has a few other interesting properties:</p>
<ul>
<li>Objects can have a piece of memory as backing (just like a normal variable in a <code>struct</code>), but can also have custom callbacks on every get and set. This allows all kinds of side effects, even though the interface of the object is the same.</li>
<li>Objects are accessible using a C++ interface, but also via name lookup by string. The generator generates a compact name parser, such that names, types, and sizes can be queried dynamically.</li>
<li>The Embedded Debugger has a standard set of commands, which can be disabled for your specific project. Moreover, you can also easily add custom commands by adding another capability in a subclass of <a class="el" href="classstored_1_1_debugger.html" title="The application-layer implementation of the Embedded Debugger protocol. ">stored::Debugger</a>.</li>
<li>There are sufficient hooks by the store to implement any application-specific synchronization method, other than the Embedded Debugger.</li>
<li>All code is normal C++, there are no platform-dependent constructs used. Therefore, all platforms are supported: Windows/Linux/Mac/bare metal (newlib), x86/ARM, gcc/clang/MSVC).</li>
</ul>
<p>Have a look in the <code>examples</code> directory for further in-depth reading. Refer to the <a href="https://demcon.github.io/libstored">Doxygen documentation</a> for the C++ API.</p>
<p><a href="https://github.com/DEMCON/libstored/actions?query=workflow%3ACI"></a></p>
<h2>Table of contents</h2>
<ul>
<li><a href="#build">How to build</a><ul>
<li><a href="#integrate">How to integrate in your build</a></li>
</ul>
</li>
<li><a href="#syntax">Syntax example</a></li>
<li><a href="#debugging">Debugging example</a></li>
<li><a href="#commands">Embedded Debugger commands</a></li>
<li><a href="#protocol">Protocol stack</a></li>
<li><a href="#license">License</a></li>
</ul>
<h2><a class="anchor" id="build"></a>How to build</h2>
<p>Run <code>scripts/bootstrap</code> (as Administrator under Windows) once to install all build dependencies. Then run <code>scripts/build</code> to build the project. This does effectively: </p><pre class="fragment">mkdir build
cd build
cmake ..
cmake --build .
</pre><p>By default, all examples are built. For example, notice that sources are generated under <code>examples/1_hello</code>, while the example itself is built in the <code>build</code> directory. The documentation can be viewed at <code>doxygen/html/index.html</code>.</p>
<p>To run all tests: </p><pre class="fragment">cmake --build . -- test
</pre><h3><a class="anchor" id="integrate"></a>How to integrate in your build</h3>
<p>Building libstored on itself is not too interesting, it is about how it can generate stuff for you. This is how to integrate it in your project:</p>
<ul>
<li>Add libstored to your source repository, for example as a submodule.</li>
<li>Run <code>scripts/bootstrap</code> in the libstored directory once to install all dependencies.</li>
<li>Include libstored to your cmake project. For example: <pre class="fragment">  set(LIBSTORED_EXAMPLES OFF CACHE BOOL "Disable libstored examples" FORCE)
  set(LIBSTORED_TESTS OFF CACHE BOOL "Disable libstored tests" FORCE)
  set(LIBSTORED_DOCUMENTATION OFF CACHE BOOL "Disable libstored documentation" FORCE)
  add_subdirectory(libstored)
</pre></li>
<li>Optional: install <code>scripts/st.vim</code> in <code>$HOME/.vim/syntax</code> to have proper syntax highlighting in vim.</li>
<li>Add some store definition file to your project, let's say <code>MyStore.st</code>. Assume you have a target <code>app</code> (which can be any type of cmake target), which is going to use <code>MyStore.st</code>, generate all required files. This will generate the sources in the <code>libstored</code> subdirectory of the current source directory, a library named <code>app-libstored</code>, and set all the dependencies right. <pre class="fragment">  add_application(app main.cpp)
  libstored_generate(app FumoStore.st)
</pre></li>
<li>Now, build your <code>app</code>. The generated libstored library is automatically built.</li>
</ul>
<p>Check out the examples of libstored, which are all independent applications with their own generated store.</p>
<h2><a class="anchor" id="syntax"></a>Syntax example</h2>
<p>See <code>examples</code> for more explanation. This is just an impression of the syntax. </p><pre class="fragment">// Comment
// Grammar: type:size[array]=initializer long name with any character

uint32 some int
int8=42 another int, which is initialized
(uint64) time (s)

{
    bool=true b
    double[2] numbers
    string:16 s
} scope
</pre><p>The generated store has variables that can be accessed like this: </p><pre class="fragment">mystore.some_int() = 10;
mystore.another_int_which_is_initialized().get();
mystore.time_s().get();
mystore.scope__b() = false;
mystore.scope__numbers_0().set(0.1);
mystore.scope__numbers_1().set(1.1);
mystore.scope__s().set("hello");
</pre><h2><a class="anchor" id="debugging"></a>Debugging example</h2>
<p>To get a grasp how debugging feels like, try the following.</p>
<ul>
<li>Build the examples, as discussed above.</li>
<li>If you use Windows, execute <code>scripts/env.cmd</code> to set your environment properly. In the instructions below, use <code>python</code> instead of <code>python3</code>.</li>
<li>Run your favorite <code>lognplot</code> instance, e.g., by running <code>python3 -m lognplot</code>.</li>
<li>Run <code>examples/zmqserver/zmqserver</code>. This starts an application with a store with all kinds of object types, and provides a ZMQ server interface for debugging.</li>
<li>Run <code>python3 <a class="el" href="gui__client_8py.html" title="A Pyside2/QtQuick GUI client. ">client/gui_client.py</a> -l</code>. This GUI connects to both the <code>zmqserver</code> application via ZMQ, and to the <code>lognplot</code> instance.</li>
<li>The GUI window will pop up and show the objects of the <code>zmqserver</code> example. If polling is enabled of one of the objects, the values are forwarded to <code>lognplot</code>.</li>
</ul>
<p>The structure of this setup is: </p><pre class="fragment">+------------+        +----------+
+ gui_client | -----&gt; | lognplot |
+------------+        +----------+
      |
      | ZeroMQ REQ/REP channel
      |
+-----------+
+ zmqserver |
+-----------+
</pre><p>The Embedded Debugger client connects via ZeroMQ. If you application does not have it, you must implement is somehow. The <code>examples/terminal/terminal</code> application could be debugged as follows:</p>
<ul>
<li>Run <code>python3 ../client/stdio_wrapper.py examples/terminal/terminal</code> from the <code>build</code> directory. This starts the <code>terminal</code> example, and extracts escaped debugger frames from <code>stdout</code>, which are forwarded to a ZeroMQ interface.</li>
<li>Connect a client, such as <code><a class="el" href="gui__client_8py.html" title="A Pyside2/QtQuick GUI client. ">client/gui_client.py</a></code>.</li>
</ul>
<p>The structure of this setup is: </p><pre class="fragment">+------------+
+ gui_client |                 terminal interface
+------------+                         |
      |                                |
      | ZeroMQ REQ/REP channel         |
      |                                |
+---------------+                      |
+ stdio_wrapper | ---------------------+
+---------------+
      |
      | stdin/stdout (mixed terminal interface
      | with Embedded Debugger messages)
      |
+----------+
+ terminal |
+----------+
</pre><h2><a class="anchor" id="commands"></a>Embedded Debugger commands</h2>
<p>A store can be queried using the following commands. These can be extended by an application.</p>
<p>Requests always start with a ASCII characters are command. Every request gets a response. Either with actual data, or with ack <code>!</code> or nack <code>?</code>. Requests are processed in order.</p>
<p>This is the OSI application layer of the protocol stack.</p>
<h3>Capabilities</h3>
<p>Request: <code>?</code> </p><pre class="fragment">?
</pre><p>Response: a list of command characters. </p><pre class="fragment">?rwe
</pre><h3>Echo</h3>
<p>Request: <code>e</code> &lt;any data&gt; </p><pre class="fragment">eHello World
</pre><p>Response: &lt;the same data&gt; </p><pre class="fragment">Hello World
</pre><h3>Read</h3>
<p>Request: <code>r</code> &lt;name of object&gt;</p>
<p>The name of the object may be abbreviated, as long as it is unambiguous. </p><pre class="fragment">r/bla/asdf
</pre><p>Response: &lt;ASCII hex value of object&gt;</p>
<p>For values with fixed length (int, float), the byte order is big/network endian. For ints, the initial zeros can be omitted. For other data, all bytes are encoded. </p><pre class="fragment">123abc
</pre><h3>Write</h3>
<p>Request: <code>w</code> &lt;value in ASCII hex&gt; &lt;name of object&gt;</p>
<p>See Read for details about the hex value and object name. </p><pre class="fragment">w10/b/a
</pre><p>Response: <code>!</code> | <code>?</code> </p><pre class="fragment">!
</pre><h3>List</h3>
<p>Requests a full list of all objects of all registered stores to the current Embedded Debugger.</p>
<p>Request: <code>l</code> </p><pre class="fragment">l
</pre><p>Response: ( &lt;type byte in hex&gt; &lt;length in hex&gt; &lt;name of object&gt; <code>\n</code> ) * | <code>?</code> </p><pre class="fragment">3b4/b/i8
201/b/b
</pre><h3>Alias</h3>
<p>Assigns a character to a object path. An alias can be everywhere where an object path is expected. Creating aliases skips parsing the object path repeatedly, so makes debugging more efficient. If no object is specified, the alias is removed. The number of aliases may be limited. If the limit is hit, the response will be <code>?</code>. The alias name can be any char in the range 0x20 - 0x7e <code>~</code>, except for 0x2f <code>/</code>.</p>
<p>Request: <code>a</code> &lt;char&gt; ( &lt;name of object&gt; ) ? </p><pre class="fragment">a0/bla/a
</pre><p>Response: <code>!</code> | <code>?</code> </p><pre class="fragment">!
</pre><h3>Macro</h3>
<p>Saves a sequence of commands and assigns a name to it. The macro name can be any char in the range 0x20 - 0x7e <code>~</code>. In case of a name clash with an existing non-macro command, the command is executed; the macro cannot hide or replace the command. The separator can be any char, as long as it is not used within a command of the macro definition. Without the definition after the macro name, the macro is removed. The system may be limited in total definition length. The macro string is reinterpreted every time it is invoked. The responses of the commands are merged into one response frame, without separators.</p>
<p>Request: <code>m</code> &lt;char&gt; ( &lt;separator&gt; &lt;command&gt; ) * </p><pre class="fragment">mZ r/bla/a e; r/bla/z
</pre><p>Response: <code>!</code> | <code>?</code> </p><pre class="fragment">!
</pre><h3>Identification</h3>
<p>Returns a fixed string that identifies the application.</p>
<p>Request: <code>i</code> </p><pre class="fragment">i
</pre><p>Response: <code>?</code> | &lt;UTF-8 encoded application name&gt; </p><pre class="fragment">libstored
</pre><h3>Version</h3>
<p>Returns a list of versions.</p>
<p>Request: <code>v</code> </p><pre class="fragment">v
</pre><p>Response: <code>?</code> | &lt;protocol version&gt; ( &lt;application-specific version&gt; ) * </p><pre class="fragment">2 r243+trunk beta
</pre><h3>Read memory</h3>
<p>Read a memory via a pointer instead of the store. Returns the number of requested bytes. If no length is specified, a word is returned.</p>
<p>Request: <code>R</code> &lt;pointer in hex&gt; ( &lt;length&gt; ) ? </p><pre class="fragment">R1ffefff7cc 4
</pre><p>Response: <code>?</code> | &lt;bytes in hex&gt; </p><pre class="fragment">efbe0000
</pre><h3>Write memory</h3>
<p>Write a memory via a pointer instead of the store.</p>
<p>Request: <code>W</code> &lt;pointer in hex&gt; &lt;bytes in hex&gt; </p><pre class="fragment">W1ffefff7cc 0123
</pre><p>Response: <code>?</code> | <code>!</code> </p><pre class="fragment">!
</pre><h3>Streams</h3>
<p>Read all available data from a stream. Streams are application-defined sequences of bytes, like stdout and stderr. They may contain binary data. There are an arbitrary number of streams, with an arbitrary single-char name.</p>
<p>To list all streams with data:</p>
<p>Request: <code>s</code></p>
<p>To request all data from a stream, where the optional suffix is appended to the response:</p>
<p>Request: <code>s</code> &lt;char&gt; &lt;suffix&gt; ? </p><pre class="fragment">sA/
</pre><p>Response: <code>?</code> | &lt;data&gt; &lt;suffix&gt; </p><pre class="fragment">Hello World!!1/
</pre><p>Once data has been read from the stream, it is removed. The next call will return new data. If a stream was never used, <code>?</code> is returned. If it was used, but it is empty now, the stream char does not show up in the <code>s</code> call, but does respond with the suffix. If no suffix was provided, and there is no data, the response is empty.</p>
<p>The number of streams and the maximum buffer size of a stream may be limited.</p>
<h2><a class="anchor" id="protocol"></a>Protocol stack</h2>
<p>Every embedded device is different, so the required protocol layers are too. What is common, is the Application layer, but as the Transport and Physical layer are often different, the layers in between are often different too. To provide a common Embedded Debugger interface, the client (e.g., GUI, CLI, python scripts), we standardize on ZeroMQ REQ/REP over TCP.</p>
<p>Not every device supports ZeroMQ, or even TCP. For this, several bridges are required. Different configurations may be possible:</p>
<ul>
<li>In case of a Linux/Windows application: embed ZeroMQ server into the application, such that the application binds to a REP socket. A client can connect to the application directly.</li>
<li>Terminal application with only stdin/stdout: use escape sequences in the stdin/stdout stream. <code><a class="el" href="stdio__wrapper_8py.html" title="A stdin/stdout frame grabber to ZmqServer wrapper for a to-be-started process. ">client/stdio_wrapper.py</a></code> is provided to inject/extract these messages from those streams and prove a ZeroMQ interface.</li>
<li>Application over CAN: like a <code><a class="el" href="stdio__wrapper_8py.html" title="A stdin/stdout frame grabber to ZmqServer wrapper for a to-be-started process. ">client/stdio_wrapper.py</a></code>, a CAN extractor to ZeroMQ bridge is required.</li>
</ul>
<p>Then, the client can be connected to the ZeroMQ interface. The following clients are provided:</p>
<ul>
<li><code>client/ed2.ZmqClient</code>: a python class that allows easy access to all objects of the connected store. This is the basis of the clients below.</li>
<li><code><a class="el" href="cli__client_8py.html" title="A Command line interface client to enter Embedded Debugger commands. ">client/cli_client.py</a></code>: a command line tool that lets you directly enter the protocol messages as defined above.</li>
<li><code><a class="el" href="gui__client_8py.html" title="A Pyside2/QtQuick GUI client. ">client/gui_client.py</a></code>: a simple GUI that shows the list of objects and lets you manipulate the values. The GUI has support to send samples to <code>lognplot</code>.</li>
</ul>
<p>Test it using the <code>terminal</code> example, started using the <code><a class="el" href="stdio__wrapper_8py.html" title="A stdin/stdout frame grabber to ZmqServer wrapper for a to-be-started process. ">client/stdio_wrapper.py</a></code>. Then connect one of the clients above to it.</p>
<h3>Application layer</h3>
<p>See above. See <a class="el" href="classstored_1_1_debugger.html" title="The application-layer implementation of the Embedded Debugger protocol. ">stored::Debugger</a>.</p>
<h3>Presentation layer</h3>
<p>For terminal or UART: In case of binary data, escape all bytes &lt; 0x20 as follows: the sequence <code>DEL</code> (0x7f) removes the 3 MSb of the successive byte. For example, the sequence <code>DEL ;</code> (0x7f 0x3b) decodes as <code>ESC</code> (0x1b). To encode <code>DEL</code> itself, repeat it. See <a class="el" href="classstored_1_1_ascii_escape_layer.html" title="Escape non-ASCII bytes. ">stored::AsciiEscapeLayer</a>.</p>
<p>For CAN/ZeroMQ: nothing required.</p>
<h3>Session layer:</h3>
<p>For terminal/UART/CAN: no session support, there is only one (implicit) session.</p>
<p>For ZeroMQ: use REQ/REP sockets, where the application-layer request and response are exactly one ZeroMQ message. All layers below are managed by ZeroMQ.</p>
<h3>Transport layer</h3>
<p>For terminal or UART: out-of-band message are captured using <code>ESC _</code> (APC) and <code>ESC \</code> (ST). A message consists of the bytes in between these sequences. See <a class="el" href="classstored_1_1_terminal_layer.html" title="Extracts and injects Embedded Debugger messages in a stream of data, such as a terminal. ">stored::TerminalLayer</a>.</p>
<p>In case of lossly channels (UART/CAN), CRC, message sequence number, and retransmits should be implemented. This depends on the specific transport hardware and embedded device.</p>
<h3>Network layer</h3>
<p>For terminal/UART/ZeroMQ, nothing has to be done.</p>
<p>For CAN: packet fragmentation/reassembling/routing is done here.</p>
<h3>Datalink layer</h3>
<p>Depends on the device.</p>
<h3>Physical layer</h3>
<p>Depends on the device.</p>
<h2><a class="anchor" id="license"></a>License</h2>
<p>The project license is specified in COPYING and COPYING.LESSER.</p>
<p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</p>
<p>You should have received a copy of the GNU Lesser General Public License along with this program. If not, see <a href="https://www.gnu.org/licenses/">https://www.gnu.org/licenses/</a>. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>

{#
vim:filetype=cpp

/*
 * libstored, a Store for Embedded Debugger.
 * Copyright (C) 2020  Jochem Rutgers
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */
-#}

#ifndef __LIBSTORED_STORE_H_{{store.name}}
#define __LIBSTORED_STORE_H_{{store.name}}

#ifdef __cplusplus

#include <libstored/macros.h>
#include <libstored/util.h>
#include <libstored/types.h>
#include <libstored/directory.h>

namespace stored {

	/*!
	 * \brief Data storage of {{store.name}}Base.
	 * \ingroup libstored_stores
	 */
#ifdef STORED_COMPILER_MSVC
	__declspec(align(8))
#endif
	struct {{store.name}}Data {
		{{store.name}}Data();

		// Value buffer.
		char buffer[{{store.buffer.size}}];

		// Directory.
		static uint8_t const* shortDirectory();
		static uint8_t const* longDirectory();
	}
#ifndef STORED_COMPILER_MSVC
	__attribute__((aligned(sizeof(double))))
#endif
	;

	/*!
	 * \brief Base class with default interface of all {{store.name}} implementations.
	 * \ingroup libstored_stores
	 */
	template <typename Implementation_>
	class {{store.name}}Base {
		CLASS_NOCOPY({{store.name}}Base)
	protected:
		{{store.name}}Base() is_default;

	public:
		typedef Implementation_ Implementation;
		char const* name() const { return "/{{store.name}}"; }

		Implementation& implementation() { return *static_cast<Implementation*>(this); }
		Implementation const& implementation() const { return *static_cast<Implementation const*>(this); }

	private:
		{{store.name}}Data m_data;
		char* buffer() { return m_data.buffer; }
		char const* buffer() const { return m_data.buffer; }

		// Accessor generators.
		template <typename T> Variable<T,Implementation> variable(size_t offset) {
			stored_assert(offset + sizeof(T) <= sizeof(m_data.buffer));
			// NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast)
			return Variable<T,Implementation>(implementation(), *reinterpret_cast<T*>(&buffer()[offset]));
		}

		template <typename T> Function<T,Implementation> function(unsigned int f) {
			return Function<T,Implementation>(implementation(), f);
		}
        
		Variant<Implementation> variant(Type::type type, size_t offset, size_t len) {
			stored_assert(offset + len < sizeof(m_data.buffer));
			stored_assert(!Type::isFunction(type));
			return Variant<Implementation>(implementation(), type, &buffer()[offset], len);
        }
		
		Variant<Implementation> variant(Type::type type, unsigned int f) {
			stored_assert(Type::isFunction(type));
			return Variant<Implementation>(implementation(), type, f);
        }
		
		template <typename T, typename I, bool H> friend class Variable;
		template <typename T, typename I> friend class Function;
		friend class Variant<Implementation>;

	protected:
		// Function callback resolver.

		size_t callback(bool UNUSED_PAR(set), void* UNUSED_PAR(buffer), size_t UNUSED_PAR(len), unsigned int UNUSED_PAR(f)) {
{% if store.objects|hasfunction %}
			switch(f) {
{%   for o in store.objects %}
{%     if o is function %}
			case {{o.f}}: // {{o}}
{%       if o is blob %}
				return implementation().__{{o.cname}}(set, static_cast<{{o|ctype}}*>(buffer), len);
{%       else %}
				stored_assert(len == sizeof({{o|ctype}}));
				// NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast)
				implementation().__{{o.cname}}(set, *reinterpret_cast<{{o|ctype}}*>(buffer));
				return sizeof({{o|ctype}});
{%       endif %}
{%     endif %}
{%   endfor %}
			default:
				return 0;
			}
{% else %}
			return 0;
{% endif %}
		}

		// Default function callback. Override in subclass.

{% for o in store.objects %}
{%   if o is function %}
{%     if o is blob %}
		/*! \brief Callback for {{o}} */
		size_t __{{o.cname}}(bool UNUSED_PAR(set), {{o|ctype}}* UNUSED_PAR(value), size_t UNUSED_PAR(len));
{%     else %}
		/*! \brief Callback for {{o}} */
		void __{{o.cname}}(bool set, {{o|ctype}}& value);
{%     endif %}
{%   endif %}
{% endfor %}

	public:
		typedef uintptr_t Key;

		/*!
		 * \brief Converts a variable's buffer to a key.
		 *
		 * A key is unique for all variables of the same store,
		 * but identical for the same variables across different instances of the same store class.
		 */
		Key bufferToKey(void const* buffer) const {
			// NOLINTNEXTLINE(cppcoreguidelines-pro-type-cstyle-cast)
			stored_assert((uintptr_t)buffer >= (uintptr_t)this->buffer() && (uintptr_t)buffer < (uintptr_t)this->buffer() + sizeof(m_data.buffer));
			// NOLINTNEXTLINE(cppcoreguidelines-pro-type-cstyle-cast)
			return (uintptr_t)buffer - (uintptr_t)this->buffer();
		}

	protected:
		// Hooks. Override in subclass when required.

		/*!
		 * \brief Hook when exclusive access to a given variable is to be acquired.
		 * \details Must be followed by #hookExitX().
		 */
		void hookEntryX(Type::type type, void* buffer, size_t len) {
			// This function is called by Variants, and alike, but the implementation
			// has to friend all of them if it overrides this function.
			// To ease integration give a default implementation that forwards the hook.
			implementation().__hookEntryX(type, buffer, len); }

		/*!
		 * \brief Hook when exclusive access to a given variable is released.
		 * \details Must be preceded by #hookEntryX().
		 */
		void hookExitX(Type::type type, void* buffer, size_t len, bool changed) {
			implementation().__hookExitX(type, buffer, len, changed); }

		/*!
		 * \brief Hook when read-only access to a given variable is to be acquired.
		 * \details Must be followed by #hookExitRO().
		 */
		void hookEntryRO(Type::type type, void* buffer, size_t len) {
			implementation().__hookEntryRO(type, buffer, len); }

		/*!
		 * \brief Hook when read-only access to a given variable is released.
		 * \details Must be preceded by #hookEntryRO().
		 */
		void hookExitRO(Type::type type, void* buffer, size_t len) {
			implementation().__hookExitRO(type, buffer, len); }

		void __hookEntryX(Type::type UNUSED_PAR(type), void* UNUSED_PAR(buffer), size_t UNUSED_PAR(len)) {}
		void __hookExitX(Type::type UNUSED_PAR(type), void* UNUSED_PAR(buffer), size_t UNUSED_PAR(len), bool UNUSED_PAR(changed)) {}
		void __hookEntryRO(Type::type UNUSED_PAR(type), void* UNUSED_PAR(buffer), size_t UNUSED_PAR(len)) {}
		void __hookExitRO(Type::type UNUSED_PAR(type), void* UNUSED_PAR(buffer), size_t UNUSED_PAR(len)) {}

	public:
		// Type-specific object accessors.

{% for o in store.objects %}
{%   if o is blob %}
{%     if o is variable %}
		/*! \brief {{o}} */
		Variant<Implementation> {{o.cname}}() { return variant({{o|stype}}, {{o.offset}}u, {{o.size}}u); }
{%     elif o is function %}
		/*! \brief {{o}} */
		Variant<Implementation> {{o.cname}}() { return variant({{o|stype}}, {{o.f}}u); }
{%     endif %}
{%   else %}
{%     if o is variable %}
		/*! \brief {{o}} */
		Variable<{{o|ctype}},Implementation> {{o.cname}}() {
			stored_assert({{o.size}}u == sizeof({{o|ctype}})); // NOLINT(hicpp-static-assert,misc-static-assert)
			return variable<{{o|ctype}}>({{o.offset}}u); }
{%     elif o is function %}
		/*! \brief {{o}} */
		Function<{{o|ctype}},Implementation> {{o.cname}}() {
			return function<{{o|ctype}}>({{o.f}}u); }
{%     endif %}
{%   endif %}
{% endfor %}

	public:
		// Directory parsers.
		uint8_t const* shortDirectory() const { return {{store.name}}Data::shortDirectory(); }
		uint8_t const* longDirectory() const { return {{store.name}}Data::longDirectory(); }

		/*!
		 * \brief Finds an object with the given name.
		 * \return the object, or an invalid #stored::Variant if not found.
		 */
		Variant<Implementation> find(char const* name, size_t len = std::numeric_limits<size_t>::max()) {
			return stored::find(implementation(), buffer(), shortDirectory(), name, len);
		}

		/*!
		 * \brief Calls a callback for every object in the #longDirectory().
		 */
		template <typename F>
		void list(F f, void* arg, char const* prefix = nullptr) { stored::list(&implementation(), buffer(), longDirectory(), f, arg, prefix); }

#if __cplusplus >= 201103L
		template <typename F>
		void list(F& f) { stored::list<Implementation,F>(&implementation(), buffer(), longDirectory(), f); }
#endif
	};
	
	/*!
	 * \brief Default {{store.name}}Base implementation.
	 * \ingroup libstored_stores
	 */
	class {{store.name}} : public {{store.name}}Base<{{store.name}}> {
		CLASS_NOCOPY({{store.name}})
	public:
		typedef {{store.name}}Base<{{store.name}}> base;
		friend class {{store.name}}Base<{{store.name}}>;
		{{store.name}}() is_default;
	protected:
{% for o in store.objects %}
{%   if o is function %}
{%     if o is blob %}
		size_t __{{o.cname}}(bool UNUSED_PAR(set), {{o|ctype}}* UNUSED_PAR(value), size_t UNUSED_PAR(len)) { return 0; }
{%     else %}
		void __{{o.cname}}(bool set, {{o|ctype}}& value) { if(!set) value = ({{o|ctype}})0; }
{%     endif %}
{%   endif %}
{% endfor %}
	};

} // namespace
#endif // __cplusplus
#endif // __LIBSTORED_STORE_H_{{store.name}}

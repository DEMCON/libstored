#ifndef __LIBSTORED_STORE_H
#define __LIBSTORED_STORE_H
// vim:filetype=cpp

#ifdef __cplusplus

#include <libstored/macros.h>
#include <libstored/util.h>
#include <libstored/types.h>

namespace stored {

	template <typename Impl>
	class Store {
	private:
		// Value buffer.
		char buffer[] = {...};

		// Accessor generators.
		template <typename T> Variable<T,Impl> variable(size_t offset, size_t len = sizeof(T)) {
			stored_assert(dynamic_cast<Impl*>(this));
			return Variable<T,Impl>(*static_cast<Impl*>(this), reinterpret_cast<T*>(&buffer[offset]), len);
		}

		template <typename T> Function<T,Impl> function(unsigned int f) {
			stored_assert(dynamic_cast<Impl*>(this));
			return Function<T,Impl>(*static_cast<Impl*>(this), f);
		}
        
		Variant variant(Type::type type, size_t offset, size_t len) {
			stored_assert(dynamic_cast<Impl*>(this));
			return Variant<Impl>(*static_cast<Impl*>(this), type, &buffer[offset], len);
        }

	protected:
		// Function callback resolver.

		size_t callback(bool UNUSED_PAR(set), void* UNUSED_PAR(buffer), size_t UNUSED_PAR(len), unsigned int UNUSED_PAR(f)) {
			stored_assert(dynamic_cast<Impl*>(this));

			switch(f)
{% for o in store.objects %}
{%   if o is function %}
			case {{o.f}}: // {{o}}
{%     if o is blob %}
				return static_cast<Impl*>(this)->{{o.cname}}(set, buffer, len);
{%     else %}
				stored_assert(len == sizeof({{o|ctype}}));
				static_cast<Impl*>(this)->{{o.cname}}(set, *reinterpret_cast<{{o|ctype}}*>(value));
				return sizeof({{o|ctype}});
{%     endif %}
{%   endif %}
{% endfor %}
			default:
				return 0;
			}
		}

		// Default function callback. Override in subclass.
{% for o in store.objects %}
{%   if o is function %}
{%     if o is blob %}
		size_t {{o.cname}}(bool UNUSED_PAR(set), {{o|ctype}}* UNUSED_PAR(value), size_t UNUSED_PAR(len)) { return 0; } // {{o}}
{%     else %}
		void {{o.cname}}(bool UNUSED_PAR(set), {{o|ctype}}& UNUSED_PAR(value)) {} // {{o}}
{%     endif %}
{%   endif %}
{% endfor %}

	public:
		// Type-specific object accessors.
{% for o in store.objects %}
{%   if o is blob %}
		Variant<Impl> {{o.cname}}() { return variant({{o|stype}}, {{o.offset}}, {{o.size}}); } // {{o}}
{%   else %}
{%     if o is variable %}
		Variable<{{o|ctype}},Impl> {{o.cname}}() { return variable<{{o|ctype}}>({{o.offset}}); } // {{o}}
{%     elif o is function %}
		Function<{{o|ctype}},Impl> {{o.cname}}() { return function<{{o|ctype}}>({{o.offset}}); } // {{o}}
{%     endif %}
{%   endif %}
{% endfor %}

	private:
		// Directory.
		static uint8_t const directory[] = {...};

		// Directory parser helpers.
		static size_t decodeOffset(uint8_t const*& p) {
			size_t v = 0;
			while(*p & 0x80) {
				v = (v << 7) | (*p & 0x7f);
				p++;
			}
			return v | *p++;
		}

		static void skipOffset(uint8_t const*& p) {
			while(*p++ & 0x80);
		}

	public:
		// Directory parsers.

		Variant find(char const* name) const {
			uint8_t const* p = nameDefinition();
			while(true) {
				if(*p == '/') {
					// Skip till next /
					while(*name != '/') { if(!*name++) return Variant(); }
					p++;
				} else if(*p == 0) {
					// end
					return Variant();
				} else if(*p >= 0x80) {
					// var
					uint8_t type = *p++ ^ 0x80;
					uint8_t len;
					if(!Type::isFixed(type))
						len = *p++;
					size_t offset = decodeOffset(++p);
					if(Type::isFunction(type))
						return Variant(*this, type, offset);
					else
						return Variant(*this, type, data + offset, len);
				} else {
					// match char
					int c = (int)*name - (int)*p++;
					if(c < 0) {
						// take jmp_l
						p += decodeOffset(p);
					} else {
						skipOffset(p);
						if(c > 0) {
							// take jmp_g
							p += decodeOffset(p);
						} else {
							// equal
							skipOffset(p);
						}
					}
				}
			}
		}
	};

} // namespace
#endif // __cplusplus
#endif // __LIBSTORED_STORE_H

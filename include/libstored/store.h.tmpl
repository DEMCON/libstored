{#
vim:filetype=cpp
-#}

#ifndef __LIBSTORED_STORE_H_{{store.name}}
#define __LIBSTORED_STORE_H_{{store.name}}

#ifdef __cplusplus

#include <libstored/macros.h>
#include <libstored/util.h>
#include <libstored/types.h>
#include <libstored/directory.h>

namespace stored {

	struct {{store.name}}Data {
		{{store.name}}Data();

		// Value buffer.
		char buffer[{{store.buffer.size}}];

		// Directory.
		static uint8_t const directory[{{store.directory.data|len}}];
	};

	template <typename Implementation>
	class {{store.name}}Base {
	private:
		{{store.name}}Data m_data;
		char* buffer() { return m_data.buffer; }
		char const* buffer() const { return m_data.buffer; }

		Implementation& implementation() { return *static_cast<Implementation*>(this); }
		Implementation const& implementation() const { return *static_cast<Implementation const*>(this); }

		// Accessor generators.
		template <typename T> Variable<T,Implementation> variable(size_t offset, size_t len = sizeof(T)) {
			return Variable<T,Implementation>(implementation(), *reinterpret_cast<T*>(&buffer()[offset]));
		}

		template <typename T> Function<T,Implementation> function(unsigned int f) {
			return Function<T,Implementation>(implementation(), f);
		}
        
		Variant<Implementation> variant(Type::type type, size_t offset, size_t len) {
			return Variant<Implementation>(implementation(), type, &buffer()[offset], len);
        }
		
		template <typename T, typename I, bool H> friend class Variable;
		template <typename T, typename I> friend class Function;
		friend class Variant<Implementation>;

	protected:
		// Function callback resolver.

		size_t callback(bool UNUSED_PAR(set), void* UNUSED_PAR(buffer), size_t UNUSED_PAR(len), unsigned int f) {
			switch(f) {
{% for o in store.objects %}
{%   if o is function %}
			case {{o.f}}: // {{o}}
{%     if o is blob %}
				return implementation().{{o.cname}}(set, buffer, len);
{%     else %}
				stored_assert(len == sizeof({{o|ctype}}));
				implementation().{{o.cname}}(set, *reinterpret_cast<{{o|ctype}}*>(buffer));
				return sizeof({{o|ctype}});
{%     endif %}
{%   endif %}
{% endfor %}
			default:
				return 0;
			}
		}

		// Default function callback. Override in subclass.

{% for o in store.objects %}
{%   if o is function %}
{%     if o is blob %}
		/*! \brief Callback for {{o}} */
		size_t {{o.cname}}(bool UNUSED_PAR(set), {{o|ctype}}* UNUSED_PAR(value), size_t UNUSED_PAR(len)) { return 0; }
{%     else %}
		/*! \brief Callback for {{o}} */
		void {{o.cname}}(bool UNUSED_PAR(set), {{o|ctype}}& UNUSED_PAR(value)) {}
{%     endif %}
{%   endif %}
{% endfor %}

		// Hooks. Override in subclass when required.
		void hookSet(Type::type UNUSED_PAR(type), void* UNUSED_PAR(key), size_t UNUSED_PAR(len)) {}

	public:
		// Type-specific object accessors.

{% for o in store.objects %}
{%   if o is blob %}
		/*! \brief {{o}} */
		Variant<Implementation> {{o.cname}}() { return variant({{o|stype}}, {{o.offset}}, {{o.size}}); }
{%   else %}
{%     if o is variable %}
		/*! \brief {{o}} */
		Variable<{{o|ctype}},Implementation> {{o.cname}}() { return variable<{{o|ctype}}>({{o.offset}}); }
{%     elif o is function %}
		/*! \brief {{o}} */
		Function<{{o|ctype}},Implementation> {{o.cname}}() { return function<{{o|ctype}}>({{o.f}}); }
{%     endif %}
{%   endif %}
{% endfor %}

	public:
		// Directory parsers.
		uint8_t const* directory() const { return m_data.directory; }

		Variant<Implementation> find(char const* name) {
			return stored::find(implementation(), buffer(), directory(), name);
		}
	};
	
	class {{store.name}} : public {{store.name}}Base<{{store.name}}> {
	};

} // namespace
#endif // __cplusplus
#endif // __LIBSTORED_STORE_H_{{store.name}}

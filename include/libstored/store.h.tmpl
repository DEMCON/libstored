{#
vim:filetype=cpp

/*
 * libstored, a Store for Embedded Debugger.
 * Copyright (C) 2020  Jochem Rutgers
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */
-#}

#ifndef __LIBSTORED_STORE_H_{{store.name}}
#define __LIBSTORED_STORE_H_{{store.name}}

#ifdef __cplusplus

#include <libstored/macros.h>
#include <libstored/util.h>
#include <libstored/types.h>
#include <libstored/directory.h>

namespace stored {

	/*!
	 * \brief Data storage of {{store.name}}Base.
	 * \ingroup libstored_stores
	 */
	struct {{store.name}}Data {
		{{store.name}}Data();

		// Value buffer.
		char buffer[{{store.buffer.size}}];

		// Directory.
		static uint8_t const* shortDirectory();
		static uint8_t const* longDirectory();
	} __attribute__((aligned(sizeof(double))));

	/*!
	 * \brief Base class with default interface of all {{store.name}} implementations.
	 * \ingroup libstored_stores
	 */
	template <typename Implementation_>
	class {{store.name}}Base {
	public:
		typedef Implementation_ Implementation;
		char const* name() const { return "/{{store.name}}"; }

		Implementation& implementation() { return *static_cast<Implementation*>(this); }
		Implementation const& implementation() const { return *static_cast<Implementation const*>(this); }

	private:
		{{store.name}}Data m_data;
		char* buffer() { return m_data.buffer; }
		char const* buffer() const { return m_data.buffer; }

		// Accessor generators.
		template <typename T> Variable<T,Implementation> variable(size_t offset) {
			stored_assert(offset + sizeof(T) <= sizeof(m_data.buffer));
			// NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast)
			return Variable<T,Implementation>(implementation(), *reinterpret_cast<T*>(&buffer()[offset]));
		}

		template <typename T> Function<T,Implementation> function(unsigned int f) {
			return Function<T,Implementation>(implementation(), f);
		}
        
		Variant<Implementation> variant(Type::type type, size_t offset, size_t len) {
			stored_assert(offset + len < sizeof(m_data.buffer));
			return Variant<Implementation>(implementation(), type, &buffer()[offset], len);
        }
		
		template <typename T, typename I, bool H> friend class Variable;
		template <typename T, typename I> friend class Function;
		friend class Variant<Implementation>;

	protected:
		// Function callback resolver.

		size_t callback(bool UNUSED_PAR(set), void* UNUSED_PAR(buffer), size_t UNUSED_PAR(len), unsigned int f) {
			switch(f) {
{% for o in store.objects %}
{%   if o is function %}
			case {{o.f}}: // {{o}}
{%     if o is blob %}
				return implementation().{{o.cname}}(set, buffer, len);
{%     else %}
				stored_assert(len == sizeof({{o|ctype}}));
				// NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast)
				implementation().__{{o.cname}}(set, *reinterpret_cast<{{o|ctype}}*>(buffer));
				return sizeof({{o|ctype}});
{%     endif %}
{%   endif %}
{% endfor %}
			default:
				return 0;
			}
		}

		// Default function callback. Override in subclass.

{% for o in store.objects %}
{%   if o is function %}
{%     if o is blob %}
		/*! \brief Callback for {{o}} */
		size_t __{{o.cname}}(bool UNUSED_PAR(set), {{o|ctype}}* UNUSED_PAR(value), size_t UNUSED_PAR(len)) { return 0; }
{%     else %}
		/*! \brief Callback for {{o}} */
		void __{{o.cname}}(bool UNUSED_PAR(set), {{o|ctype}}& UNUSED_PAR(value)) {}
{%     endif %}
{%   endif %}
{% endfor %}

	public:
		typedef uintptr_t Key;

		/*!
		 * \brief Converts a variable's buffer to a key.
		 *
		 * A key is unique for all variables of the same store,
		 * but identical for the same variables across different instances of the same store class.
		 */
		Key bufferToKey(void const* buffer) const {
			// NOLINTNEXTLINE(cppcoreguidelines-pro-type-cstyle-cast)
			stored_assert((uintptr_t)buffer >= (uintptr_t)this->buffer() && (uintptr_t)buffer < (uintptr_t)this->buffer() + sizeof(m_data.buffer));
			// NOLINTNEXTLINE(cppcoreguidelines-pro-type-cstyle-cast)
			return (uintptr_t)buffer - (uintptr_t)this->buffer();
		}

	protected:
		// Hooks. Override in subclass when required.

		/*!
		 * \brief Hook to be called after a variable has been set.
		 */
		void hookSet(Type::type UNUSED_PAR(type), void* UNUSED_PAR(buffer), size_t UNUSED_PAR(len)) {}

	public:
		// Type-specific object accessors.

{% for o in store.objects %}
{%   if o is blob %}
		/*! \brief {{o}} */
		Variant<Implementation> {{o.cname}}() { return variant({{o|stype}}, {{o.offset}}, {{o.size}}); }
{%   else %}
{%     if o is variable %}
		/*! \brief {{o}} */
		Variable<{{o|ctype}},Implementation> {{o.cname}}() { return variable<{{o|ctype}}>({{o.offset}}); }
{%     elif o is function %}
		/*! \brief {{o}} */
		Function<{{o|ctype}},Implementation> {{o.cname}}() { return function<{{o|ctype}}>({{o.f}}); }
{%     endif %}
{%   endif %}
{% endfor %}

	public:
		// Directory parsers.
		uint8_t const* shortDirectory() const { return {{store.name}}Data::shortDirectory(); }
		uint8_t const* longDirectory() const { return {{store.name}}Data::longDirectory(); }

		/*!
		 * \brief Finds an object with the given name.
		 * \return the object, or an invalid #stored::Variant if not found.
		 */
		Variant<Implementation> find(char const* name, size_t len = std::numeric_limits<size_t>::max()) {
			return stored::find(implementation(), buffer(), shortDirectory(), name, len);
		}

		/*!
		 * \brief Calls a callback for every object in the #longDirectory().
		 */
		template <typename F>
		void list(F f, void* arg, char const* prefix = nullptr) { stored::list(&implementation(), buffer(), longDirectory(), f, arg, prefix); }

#if __cplusplus >= 201103L
		template <typename F>
		void list(F& f) { stored::list<Implementation,F>(&implementation(), buffer(), longDirectory(), f); }
#endif
	};
	
	/*!
	 * \brief Default {{store.name}}Base implementation.
	 * \ingroup libstored_stores
	 */
	class {{store.name}} : public {{store.name}}Base<{{store.name}}> {
	};

} // namespace
#endif // __cplusplus
#endif // __LIBSTORED_STORE_H_{{store.name}}
